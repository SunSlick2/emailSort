# -*- coding: utf-8 -*-
"""Email_Sorter_Python_Application_(Version_38_10_BossEmail_ToField_Only).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/SunSlick2/emailSort/blob/main/Email_Sorter_Python_Application_(Version_38_10_BossEmail_ToField_Only).ipynb
"""

import os
import win32com.client
import pandas as pd
import datetime
import openpyxl
import tkinter as tk
from tkinter import messagebox
from tkinter import simpledialog
from tkcalendar import Calendar
import threading
import logging
import time
import json
import re
import pythoncom

class EmailSorter:
    """
    A class to sort emails in Outlook based on rules defined in an Excel file
    and configuration from a JSON file.
    Supports live monitoring and bulk processing modes.
    Version 38.10: Modified BossEmail rule (Rule 10) to only check "To" field instead of all recipients
    """

    # Define config file path once here for consistency
    CONFIG_FILE_NAME = 'configv38.09.json'

    def __init__(self, config_path=None):
        """
        Initializes the EmailSorter with configuration, sets up paths,
        loads data from Excel.
        """
        # Use provided config_path or the default class-level constant
        self.config_path = config_path if config_path else self.CONFIG_FILE_NAME

        self.config = None
        self.xls_path = None
        self.log_live_path = None
        self.log_bulk_path = None
        self.log_invalid_path = None

        # Data holders for loaded rules
        self.keyword_subject_to_delete1_keywords = set()
        self.trade_keywords = set()
        self.my_cliente_emails = set()
        self.dacs_notmine_emails = set()
        self.my_client_keywords = set()
        self.dacs_notmine_keywords = set()
        self.trade_details_emails = set()
        self.research_emails = set()
        self.research_keywords = set()
        self.boss_emails = set()
        self.keyword_subject_to_delete_keywords = set()

        self.smtp_cache = {}
        self.new_smtp_entries = {}

        self.live_running = False
        self.invalid_logger = None
        self.live_logger = None
        self.bulk_logger = None

        # Live mode scheduling state
        # Initialized to None to explicitly indicate no check has occurred yet
        self.last_midnight_check_hour = None

        try:
            self._load_config()
            self.setup_paths()
            self.setup_logging()

            self.load_data() # Load all data from Excel

            self.invalid_logger.info("EmailSorter initialized successfully.")
        except Exception as e:
            error_message = f"Initialization error: {e}"
            print(error_message)
            if self.invalid_logger:
                self.invalid_logger.error(f"InitializationError||EmailSorter.__init__|{error_message}")
            messagebox.showerror("Initialization Error", error_message)
            raise

    def _load_config(self):
        """
        Loads configuration from the JSON file.
        Ensures essential paths and sheet mappings are present and correctly formatted.
        """
        try:
            print(f"Attempting to load config from: {os.path.abspath(self.config_path)}")
            with open(self.config_path, 'r') as f:
                self.config = json.load(f)

            print(f"Keys found in sheet_map: {list(self.config['sheet_map'].keys())}")

            required_top_level_keys = ['xls_path', 'log_live_path', 'log_bulk_path', 'log_invalid_path', 'sheet_map']
            for key in required_top_level_keys:
                if key not in self.config:
                    raise ValueError(f"Missing required top-level configuration key: '{key}'")

            # Define expected structure for each rule type in sheet_map
            expected_rule_structure = {
                "KeywordSubject_ToDelete1": {"sheet": str, "columns": list, "match_field": str, "destination_name": str},
                "TradeKeyword": {"sheet": str, "column": str, "match_field": str, "destination_name": str},
                "MyClienteMailAddresses": {"sheet": str, "column": str, "destination_name": str},
                "DACSNotMineEmail": {"sheet": str, "column": str, "destination_name": str},
                "MyClientKeywords": {"sheet": str, "columns": list, "match_field": str, "destination_name": str},
                "DACSNotMineKeyword": {"sheet": str, "columns": list, "match_field": str, "destination_name": str},
                "TradeDetailseMailAddresses": {"sheet": str, "column": str, "destination_name": str},
                "ResearchEmail": {"sheet": str, "column": str, "destination_name": str},
                "ResearchKeyword": {"sheet": str, "column": str, "match_field": str, "destination_name": str},
                "BossEmail": {"sheet": str, "column": str, "destination_name": str},
                "KeywordSubject_ToDelete": {"sheet": str, "column": str, "match_field": str, "destination_name": str},
                "SMTPResolutionCache": {"sheet": str} # Column key is optional/can be null
            }

            for rule_name, required_keys in expected_rule_structure.items():
                if rule_name not in self.config['sheet_map']:
                    raise ValueError(f"Missing required rule configuration in sheet_map: '{rule_name}'")

                rule_config = self.config['sheet_map'][rule_name]
                for key, expected_type in required_keys.items():
                    if key not in rule_config:
                        # Allow 'column' to be missing if 'columns' is expected, or vice-versa
                        if (key == "column" and "columns" in rule_config) or \
                           (key == "columns" and "column" in rule_config):
                            continue # One of them is present, which is fine
                        if key == "match_field" and rule_name in ["MyClienteMailAddresses", "DACSNotMineEmail", 
                                                                  "TradeDetailseMailAddresses", "ResearchEmail", 
                                                                  "BossEmail"]:
                            continue # These don't need match_field as they're email address based
                        raise ValueError(f"Missing required key '{key}' for rule '{rule_name}' in sheet_map.")
                    if not isinstance(rule_config[key], expected_type):
                        # Special handling for column/columns
                        if (key == "columns" and not (isinstance(rule_config[key], list) and len(rule_config[key]) > 0)) or \
                           (key == "column" and not isinstance(rule_config[key], str)):
                            raise ValueError(f"Invalid type for key '{key}' in rule '{rule_name}'. Expected {expected_type.__name__}.")

                # Specific checks for match_field if present
                if "match_field" in rule_config and rule_config["match_field"] not in ['subject_only', 'subject_and_body']:
                    raise ValueError(f"Invalid 'match_field' for '{rule_name}'. Must be 'subject_only' or 'subject_and_body'.")

            print(f"Configuration loaded successfully from {self.config_path}")
        except FileNotFoundError:
            raise FileNotFoundError(f"Configuration file {self.config_path} not found.")
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON in configuration file: {e}")
        except ValueError as e:
            raise e

    def setup_paths(self):
        """Sets up file paths from the loaded configuration."""
        self.xls_path = self.config['xls_path']
        self.log_live_path = self.config['log_live_path']
        self.log_bulk_path = self.config['log_bulk_path']
        self.log_invalid_path = self.config['log_invalid_path']

        os.makedirs(os.path.dirname(self.log_live_path) or '.', exist_ok=True)
        os.makedirs(os.path.dirname(self.log_bulk_path) or '.', exist_ok=True)
        os.makedirs(os.path.dirname(self.log_invalid_path) or '.', exist_ok=True)

        print(f"Paths set: Excel='{self.xls_path}', LiveLog='{self.log_live_path}', BulkLog='{self.log_bulk_path}', InvalidLog='{self.log_invalid_path}'")

    def setup_logging(self):
        """Configures logging for live, bulk, and invalid email entries."""
        self.invalid_logger = self._create_logger('invalid_log', self.log_invalid_path, level=logging.ERROR)
        self.live_logger = self._create_logger('live_log', self.log_live_path, level=logging.INFO)
        self.bulk_logger = self._create_logger('bulk_log', self.log_bulk_path, level=logging.INFO)
        print("Logging setup complete.")

    def _create_logger(self, name, log_path, level=logging.INFO):
        """Helper to create and configure a logger."""
        logger = logging.getLogger(name)
        logger.setLevel(level)

        if logger.handlers:
            for handler in list(logger.handlers):
                logger.removeHandler(handler)

        handler = logging.FileHandler(log_path, mode='a', encoding='utf-8')
        formatter = logging.Formatter('%(asctime)s|%(levelname)s|%(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        return logger

    def load_data(self):
        """
        Loads all necessary data (email addresses, keywords, SMTP cache)
        from the configured Excel file based on the sheet_map.
        """
        try:
            self.tables = pd.read_excel(self.xls_path, sheet_name=None, dtype=str, engine='openpyxl')
            print(f"Excel file '{self.xls_path}' loaded successfully.")
        except FileNotFoundError:
            error_msg = f"Excel file not found: {self.xls_path}"
            self.invalid_logger.error(f"FileLoadError||load_data|{error_msg}")
            raise FileNotFoundError(error_msg)
        except Exception as e:
            error_msg = f"Error reading Excel file: {e}"
            self.invalid_logger.error(f"ExcelReadError||load_data|{error_msg}")
            raise ValueError(error_msg)

        # Load data for each rule based on its type in the config
        try:
            self.keyword_subject_to_delete1_keywords = self._load_keywords('KeywordSubject_ToDelete1')
            print(f"Loaded {len(self.keyword_subject_to_delete1_keywords)} 'to delete 1' subject keywords.")
        except Exception as e:
            self.invalid_logger.error(f"DataLoadError|KeywordSubject_ToDelete1|load_data|{e}")
            print(f"Warning: Could not load KeywordSubject_ToDelete1: {e}")

        try:
            self.trade_keywords = self._load_single_column_keywords('TradeKeyword')
            print(f"Loaded {len(self.trade_keywords)} trade keywords.")
        except Exception as e:
            self.invalid_logger.error(f"DataLoadError|TradeKeyword|load_data|{e}")
            print(f"Warning: Could not load TradeKeyword: {e}")

        try:
            self.my_cliente_emails = self._load_email_addresses('MyClienteMailAddresses')
            print(f"Loaded {len(self.my_cliente_emails)} client email addresses.")
        except Exception as e:
            self.invalid_logger.error(f"DataLoadError|MyClienteMailAddresses|load_data|{e}")
            print(f"Warning: Could not load MyClienteMailAddresses: {e}")

        try:
            self.dacs_notmine_emails = self._load_email_addresses('DACSNotMineEmail')
            print(f"Loaded {len(self.dacs_notmine_emails)} non-mine email addresses.")
        except Exception as e:
            self.invalid_logger.error(f"DataLoadError|DACSNotMineEmail|load_data|{e}")
            print(f"Warning: Could not load DACSNotMineEmail: {e}")

        try:
            self.my_client_keywords = self._load_keywords('MyClientKeywords')
            print(f"Loaded {len(self.my_client_keywords)} my client keywords.")
        except Exception as e:
            self.invalid_logger.error(f"DataLoadError|MyClientKeywords|load_data|{e}")
            print(f"Warning: Could not load MyClientKeywords: {e}")

        try:
            self.dacs_notmine_keywords = self._load_keywords('DACSNotMineKeyword')
            print(f"Loaded {len(self.dacs_notmine_keywords)} non-mine keywords.")
        except Exception as e:
            self.invalid_logger.error(f"DataLoadError|DACSNotMineKeyword|load_data|{e}")
            print(f"Warning: Could not load DACSNotMineKeyword: {e}")

        try:
            self.trade_details_emails = self._load_email_addresses('TradeDetailseMailAddresses')
            print(f"Loaded {len(self.trade_details_emails)} trade details email addresses.")
        except Exception as e:
            self.invalid_logger.error(f"DataLoadError|TradeDetailseMailAddresses|load_data|{e}")
            print(f"Warning: Could not load TradeDetailseMailAddresses: {e}")

        try:
            self.research_emails = self._load_email_addresses('ResearchEmail')
            print(f"Loaded {len(self.research_emails)} research email addresses.")
        except Exception as e:
            self.invalid_logger.error(f"DataLoadError|ResearchEmail|load_data|{e}")
            print(f"Warning: Could not load ResearchEmail: {e}")

        try:
            self.research_keywords = self._load_single_column_keywords('ResearchKeyword')
            print(f"Loaded {len(self.research_keywords)} research keywords.")
        except Exception as e:
            self.invalid_logger.error(f"DataLoadError|ResearchKeyword|load_data|{e}")
            print(f"Warning: Could not load ResearchKeyword: {e}")

        try:
            self.boss_emails = self._load_email_addresses('BossEmail')
            print(f"Loaded {len(self.boss_emails)} boss email addresses.")
        except Exception as e:
            self.invalid_logger.error(f"DataLoadError|BossEmail|load_data|{e}")
            print(f"Warning: Could not load BossEmail: {e}")

        try:
            self.keyword_subject_to_delete_keywords = self._load_single_column_keywords('KeywordSubject_ToDelete')
            print(f"Loaded {len(self.keyword_subject_to_delete_keywords)} 'to delete' subject keywords.")
        except Exception as e:
            self.invalid_logger.error(f"DataLoadError|KeywordSubject_ToDelete|load_data|{e}")
            print(f"Warning: Could not load KeywordSubject_ToDelete: {e}")

        try:
            self.smtp_cache = self._load_smtp_cache()
            print(f"Loaded {len(self.smtp_cache)} SMTP cache entries.")
        except Exception as e:
            self.invalid_logger.error(f"DataLoadError|SMTPResolutionCache|load_data|{e}")
            print(f"Warning: Could not load SMTPResolutionCache: {e}")

        self.new_smtp_entries = {}

    def _load_email_addresses(self, rule_name):
        """Loads email addresses from a specified Excel sheet and column."""
        sheet_config = self.config['sheet_map'][rule_name]
        sheet_name = sheet_config['sheet']
        column_name = sheet_config['column']

        if sheet_name not in self.tables:
            raise ValueError(f"Sheet '{sheet_name}' not found in Excel file for '{rule_name}'")

        df = self.tables[sheet_name]
        if column_name not in df.columns:
            raise ValueError(f"Column '{column_name}' not found in sheet '{sheet_name}' for '{rule_name}'")

        return set(df[column_name].dropna().astype(str).str.lower())

    def _load_single_column_keywords(self, rule_name):
        """
        Loads keywords from a specified Excel sheet with a single column.
        Includes stripping leading/trailing whitespace.
        """
        sheet_config = self.config['sheet_map'][rule_name]
        sheet_name = sheet_config['sheet']
        column_name = sheet_config['column']

        if sheet_name not in self.tables:
            raise ValueError(f"Sheet '{sheet_name}' not found in Excel file for '{rule_name}'")

        df = self.tables[sheet_name]
        if column_name not in df.columns:
            raise ValueError(f"Column '{column_name}' not found in sheet '{sheet_name}' for '{rule_name}'")

        keywords = set(
            df[column_name]
            .dropna()
            .astype(str)
            .str.strip()
            .str.lower()
        )
        keywords.discard('')
        return keywords

    def _load_keywords(self, rule_name):
        """
        Loads keywords from a specified Excel sheet and multiple columns.
        Includes stripping leading/trailing whitespace.
        """
        sheet_config = self.config['sheet_map'][rule_name]
        sheet_name = sheet_config['sheet']
        columns = sheet_config['columns'] # Expects a list of columns

        if sheet_name not in self.tables:
            raise ValueError(f"Sheet '{sheet_name}' not found in Excel file for '{rule_name}'")

        df = self.tables[sheet_name]

        missing_columns = [col for col in columns if col not in df.columns]
        if missing_columns:
            raise ValueError(f"Columns {missing_columns} not found in sheet '{sheet_name}' for '{rule_name}'")

        keywords = set()
        for column in columns:
            column_values = df[column].dropna().astype(str).str.strip().str.lower()
            keywords.update(column_values)

        keywords.discard('')
        return keywords

    def _load_smtp_cache(self):
        """Loads SMTP resolution cache from the 'SMTPResolutionCache' sheet."""
        cache_sheet_name = self.config['sheet_map']['SMTPResolutionCache']['sheet']
        if cache_sheet_name in self.tables:
            cache_df = self.tables[cache_sheet_name]
            if 'EntryName' in cache_df.columns and 'SMTPAddress' in cache_df.columns:
                return dict(zip(
                    cache_df['EntryName'].fillna('').astype(str).str.lower(),
                    cache_df['SMTPAddress'].fillna('').astype(str).str.lower()
                ))
            else:
                self.invalid_logger.warning(
                    f"Missing 'EntryName' or 'SMTPAddress' columns in '{cache_sheet_name}' sheet. "
                    "SMTP cache will not be loaded."
                )
        else:
            self.invalid_logger.warning(
                f"Sheet '{cache_sheet_name}' not found in Excel file. SMTP cache will not be loaded."
            )
        return {}

    def get_smtp_address(self, outlook_namespace, entry):
        """Resolves the SMTP email address for an Outlook recipient or sender entry."""
        if not entry:
            self.invalid_logger.warning("NullEntry||get_smtp_address|Received a None entry.")
            return None

        name = getattr(entry, 'Name', '') or ''
        address = getattr(entry, 'Address', '') or ''
        name_key = (name.lower() if name else address.lower()) or ''

        if not name_key:
            self.invalid_logger.warning(f"EmptyNameKey|Name: '{name}', Address: '{address}'|get_smtp_address|No usable identifier for SMTP lookup.")
            return None

        cached = self.smtp_cache.get(name_key)
        if cached:
            return cached

        smtp = None
        try:
            smtp = entry.PropertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x39FE001E")
            if smtp:
                smtp = smtp.lower()
        except Exception:
            pass

        if not smtp and address:
            smtp = address.lower()

        if smtp:
            self.new_smtp_entries[name_key] = smtp
            self.smtp_cache[name_key] = smtp
            return smtp
        else:
            self.invalid_logger.info(f"NoSMTPResolution|Name: '{name}', Address: '{address}'|get_smtp_address|Could not resolve SMTP address.")
            return None

    def extract_addresses(self, outlook_namespace, mail):
        """Extracts all relevant email addresses (recipients and sender) from a mail item."""
        recipients = set()

        # Extract recipients (To, Cc, Bcc)
        try:
            for rec in mail.Recipients:
                smtp = self.get_smtp_address(outlook_namespace, rec)
                if smtp:
                    recipients.add(smtp)
        except Exception as e:
            self.invalid_logger.error(f"RecipientParseError|{mail.Subject or 'NoSubject'}|extract_addresses|{e}")

        # Extract sender
        sender = None
        try:
            sender = self.get_smtp_address(outlook_namespace, mail.Sender)
            if sender:
                recipients.add(sender)
        except Exception as e:
            self.invalid_logger.error(f"SenderParseError|{mail.Subject or 'NoSubject'}|extract_addresses|{e}")

        if not recipients:
            self.invalid_logger.error(f"NoAddressesFound|Subject: '{mail.Subject or 'NoSubject'}'|extract_addresses|No sender or recipient addresses extracted.")
        return recipients
    
    def extract_to_addresses_only(self, outlook_namespace, mail):
        """
        Extracts only email addresses from the "To" field of a mail item.
        Used specifically for the BossEmail rule.
        """
        to_addresses = set()
        
        try:
            for rec in mail.Recipients:
                # Check if recipient is in the "To" field (Type == 1 for olTo)
                if hasattr(rec, 'Type') and rec.Type == 1:
                    smtp = self.get_smtp_address(outlook_namespace, rec)
                    if smtp:
                        to_addresses.add(smtp)
        except Exception as e:
            self.invalid_logger.error(f"ToFieldParseError|{mail.Subject or 'NoSubject'}|extract_to_addresses_only|{e}")
            
        return to_addresses

    def _strip_html_tags(self, html_string):
        """
        Strips HTML tags, converts HTML entities, and normalizes whitespace
        to produce clean plain text for matching.
        """
        if not html_string:
            return ""

        # Decode common HTML entities to their character equivalents
        html_string = html_string.replace('&nbsp;', ' ')
        html_string = html_string.replace('&amp;', '&')
        html_string = html_string.replace('&lt;', '<')
        html_string = html_string.replace('&gt;', '>')
        html_string = html_string.replace('&quot;', '"')
        html_string = html_string.replace('&#x27;', "'") # apostrophe
        html_string = html_string.replace('&#39;', "'") # apostrophe
        html_string = html_string.replace('&#8217;', "'") # right single quotation mark
        html_string = html_string.replace('&#8211;', '-') # en dash
        html_string = html_string.replace('&#8212;', '--') # em dash
        html_string = html_string.replace('&mdash;', '--') # em dash
        html_string = html_string.replace('&ndash;', '-') # en dash

        # Remove script and style tags and their content first
        clean_text = re.sub(r'<script[^>]*>.*?</script>', '', html_string, flags=re.DOTALL | re.IGNORECASE)
        clean_text = re.sub(r'<style[^>]*>.*?</style>', '', clean_text, flags=re.DOTALL | re.IGNORECASE)

        # Replace <br> and <p> tags with newlines to preserve some structure
        clean_text = re.sub(r'<br\s*/?>', '\n', clean_text, flags=re.IGNORECASE)
        clean_text = re.sub(r'</p>', '\n\n', clean_text, flags=re.IGNORECASE) # Paragraph end

        # Remove all other HTML tags
        clean_text = re.sub(r'<[^>]*>', '', clean_text)

        # Normalize whitespace: replace multiple spaces/tabs/newlines with a single space
        clean_text = re.sub(r'\s+', ' ', clean_text).strip()

        return clean_text

    def keyword_match(self, mail, keywords, match_field="subject_and_body"):
        """
        Checks if any of the provided keywords matches a phrase/word in the
        subject or body of the email based on match_field, using regex for substring matching.
        It prioritizes the cleaned HTML body content if available.
        """
        try:
            subject = (mail.Subject or "").lower()

            # Get and clean HTML body first
            body_html_cleaned = ""
            try:
                if hasattr(mail, 'HTMLBody') and mail.HTMLBody:
                    body_html_cleaned = self._strip_html_tags(mail.HTMLBody).lower()
            except Exception as e:
                self.invalid_logger.warning(f"HTMLBodyReadError|{mail.Subject or 'NoSubject'}|keyword_match|Failed to read or strip HTMLBody: {e}")

            # Fallback to plain text body if HTML is empty or failed
            body_plain_text = (mail.Body or "").lower()

            target_content_strings = []
            if match_field == "subject_only":
                target_content_strings.append(subject)
            elif match_field == "subject_and_body":
                target_content_strings.append(subject)
                # Use cleaned HTML body if it has content, otherwise fall back to plain text body
                if body_html_cleaned:
                    target_content_strings.append(body_html_cleaned)
                else:
                    target_content_strings.append(body_plain_text)
            else:
                self.invalid_logger.error(f"InvalidMatchField|{mail.Subject or 'NoSubject'}|keyword_match|Unknown match_field: {match_field}. Defaulting to subject_and_body.")
                target_content_strings.append(subject)
                if body_html_cleaned:
                    target_content_strings.append(body_html_cleaned)
                else:
                    target_content_strings.append(body_plain_text)

            for keyword in keywords:
                # Escape the keyword to treat it as a literal string in regex
                # No word boundaries for substring matching
                pattern = re.escape(keyword)
                regex = re.compile(pattern, re.IGNORECASE)

                for content_string in target_content_strings:
                    if regex.search(content_string):
                        return keyword # Return the first matching keyword
            return None
        except Exception as e:
            self.invalid_logger.error(f"KeywordMatchError|{mail.Subject or 'NoSubject'}|keyword_match|{e}")
            return None

    def log_email(self, logger, outlook_namespace, mail, match_info, dest_folder_name):
        """Logs processed email information to the specified logger."""
        try:
            sent_on = mail.SentOn
            date_str = sent_on.strftime("%Y-%m-%d")
            time_str = sent_on.strftime("%H:%M:%S")

            sender_smtp = self.get_smtp_address(outlook_namespace, mail.Sender) or "Unknown"

            subject = (mail.Subject or "NoSubject").replace('|', ' ').replace('\n', ' ').strip()

            log_entry = f"{date_str}|{time_str}|{sender_smtp}|{subject}|{match_info}|{dest_folder_name}"
            logger.info(log_entry)
        except Exception as e:
            self.invalid_logger.error(
                f"LogFormatError|Subject: '{getattr(mail, 'Subject', 'NoSubject') or 'NoSubject'}'|"
                f"log_email|Failed to format log entry: {e}"
            )

    def _get_or_create_outlook_folder(self, outlook_namespace, folder_path):
        """
        Gets an Outlook folder object by its path, creating it and any necessary
        parent folders if they don't exist.
        Path can be nested, e.g., "Inbox\\SubFolder\\SubSubFolder".
        It handles paths starting with standard folder names or implicitly
        creates subfolders under Inbox if no root is specified.
        """
        path_parts = folder_path.split('\\')
        current_folder = None

        # Determine the initial root folder
        first_part_lower = path_parts[0].lower()

        # Try to get default folders by their common names first
        if first_part_lower == "inbox":
            current_folder = outlook_namespace.GetDefaultFolder(6) # olFolderInbox
            path_parts = path_parts[1:] # Remove "Inbox" from parts to process
        elif first_part_lower == "sent items":
            current_folder = outlook_namespace.GetDefaultFolder(5) # olFolderSentMail
            path_parts = path_parts[1:] # Remove "Sent Items" from parts to process
        else:
            # If the path doesn't start with "Inbox" or "Sent Items", assume it's
            # intended as a subfolder of Inbox.
            current_folder = outlook_namespace.GetDefaultFolder(6) # olFolderInbox
            # path_parts remains as is, e.g., ["DACS-My"] will be created directly under Inbox

        # Iterate through the remaining parts of the path, creating folders as needed
        for sub_folder_name in path_parts:
            # Skip empty parts (e.g., if path was "Inbox\\")
            if not sub_folder_name:
                continue

            try:
                # Attempt to get the subfolder
                current_folder = current_folder.Folders.Item(sub_folder_name)
            except Exception:
                # Folder does not exist, create it
                current_folder = current_folder.Folders.Add(sub_folder_name)
                print(f"Created Outlook folder: '{sub_folder_name}' under '{current_folder.Parent.Name}'")
        return current_folder

    def process_email(self, outlook_namespace, mail, logger, folder_objects_map):
        """
        Processes a single email: finds matching rules and moves the email.
        Rule order updated according to sheet numbering in configv38.09.json:
        1. KeywordSubject_ToDelete1
        2. TradeKeyword
        3. MyClienteMailAddresses
        4. DACSNotMineEmail
        5. MyClientKeywords
        6. DACSNotMineKeyword
        7. TradeDetailseMailAddresses
        8. ResearchEmail
        9. ResearchKeyword
        10. BossEmail (Only checks "To" field)
        11. KeywordSubject_ToDelete
        """
        try:
            recipients = self.extract_addresses(outlook_namespace, mail)

            # Rule 1: Keyword in subject ONLY from KeywordSubject_ToDelete1 (highest priority)
            if self.keyword_match(mail, self.keyword_subject_to_delete1_keywords, match_field="subject_only"):
                dest_folder_name = self.config['sheet_map']['KeywordSubject_ToDelete1']['destination_name']
                mail.Move(folder_objects_map[dest_folder_name])
                self.log_email(logger, outlook_namespace, mail, "Matched by KeywordSubject_ToDelete1", dest_folder_name)
                return True

            # Rule 2: Keyword in subject ONLY from TradeKeyword
            if self.keyword_match(mail, self.trade_keywords, match_field="subject_only"):
                dest_folder_name = self.config['sheet_map']['TradeKeyword']['destination_name']
                mail.Move(folder_objects_map[dest_folder_name])
                self.log_email(logger, outlook_namespace, mail, "Matched by TradeKeyword", dest_folder_name)
                return True

            # Rule 3: Email address in MyClienteMailAddresses
            if any(addr in self.my_cliente_emails for addr in recipients):
                dest_folder_name = self.config['sheet_map']['MyClienteMailAddresses']['destination_name']
                mail.Move(folder_objects_map[dest_folder_name])
                self.log_email(logger, outlook_namespace, mail, "Matched by MyClienteMailAddresses", dest_folder_name)
                return True

            # Rule 4: Email address in DACSNotMineEmail
            if any(addr in self.dacs_notmine_emails for addr in recipients):
                dest_folder_name = self.config['sheet_map']['DACSNotMineEmail']['destination_name']
                mail.Move(folder_objects_map[dest_folder_name])
                self.log_email(logger, outlook_namespace, mail, "Matched by DACSNotMineEmail", dest_folder_name)
                return True

            # Rule 5: Keyword in subject/body from MyClientKeywords
            if self.keyword_match(mail, self.my_client_keywords, match_field="subject_and_body"):
                dest_folder_name = self.config['sheet_map']['MyClientKeywords']['destination_name']
                mail.Move(folder_objects_map[dest_folder_name])
                self.log_email(logger, outlook_namespace, mail, f"Matched by MyClientKeywords", dest_folder_name)
                return True

            # Rule 6: Keyword in subject/body from DACSNotMineKeyword
            if self.keyword_match(mail, self.dacs_notmine_keywords, match_field="subject_and_body"):
                dest_folder_name = self.config['sheet_map']['DACSNotMineKeyword']['destination_name']
                mail.Move(folder_objects_map[dest_folder_name])
                self.log_email(logger, outlook_namespace, mail, f"Matched by DACSNotMineKeyword", dest_folder_name)
                return True

            # Rule 7: Email address in TradeDetailseMailAddresses
            if any(addr in self.trade_details_emails for addr in recipients):
                dest_folder_name = self.config['sheet_map']['TradeDetailseMailAddresses']['destination_name']
                mail.Move(folder_objects_map[dest_folder_name])
                self.log_email(logger, outlook_namespace, mail, "Matched by TradeDetailseMailAddresses", dest_folder_name)
                return True

            # Rule 8: Email address in ResearchEmail
            if any(addr in self.research_emails for addr in recipients):
                dest_folder_name = self.config['sheet_map']['ResearchEmail']['destination_name']
                mail.Move(folder_objects_map[dest_folder_name])
                self.log_email(logger, outlook_namespace, mail, "Matched by ResearchEmail", dest_folder_name)
                return True

            # Rule 9: Keyword in subject ONLY from ResearchKeyword
            if self.keyword_match(mail, self.research_keywords, match_field="subject_only"):
                dest_folder_name = self.config['sheet_map']['ResearchKeyword']['destination_name']
                mail.Move(folder_objects_map[dest_folder_name])
                self.log_email(logger, outlook_namespace, mail, "Matched by ResearchKeyword", dest_folder_name)
                return True

            # Rule 10: Email address in BossEmail (ONLY checks "To" field)
            to_addresses = self.extract_to_addresses_only(outlook_namespace, mail)
            if any(addr in self.boss_emails for addr in to_addresses):
                dest_folder_name = self.config['sheet_map']['BossEmail']['destination_name']
                mail.Move(folder_objects_map[dest_folder_name])
                self.log_email(logger, outlook_namespace, mail, "Matched by BossEmail (To field only)", dest_folder_name)
                return True

            # Rule 11: Keyword in subject ONLY from KeywordSubject_ToDelete (lowest priority)
            if self.keyword_match(mail, self.keyword_subject_to_delete_keywords, match_field="subject_only"):
                dest_folder_name = self.config['sheet_map']['KeywordSubject_ToDelete']['destination_name']
                mail.Move(folder_objects_map[dest_folder_name])
                self.log_email(logger, outlook_namespace, mail, f"Matched by KeywordSubject_ToDelete", dest_folder_name)
                return True

            # If no rules matched, log to original folder name
            self.log_email(logger, outlook_namespace, mail, "No matching rules", mail.Parent.Name)
            return False

        except Exception as e:
            subject = getattr(mail, 'Subject', 'Unknown') or 'NoSubject'
            self.invalid_logger.error(f"EmailProcessingError|Subject: '{subject}'|process_email|{e}")
            print(f"Error processing email '{subject}': {e}")
            return False

    def _get_live_mode_start_filter_time(self):
        """
        Determines the start_time_filter for live mode based on current day of week